# 2.1 JSX란?

JSX는 리액트만의 전유물이 아니다.
JSX의 기존 목표는 JSX 내부에 "트리 구조"로 표현하고 싶은 다양한 것들을 작성해두고, 이 JSX를 transfile이라는 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경하는 것이다.
\*JSX의 상세한 스펙은 생략하고 간단하게 알아볼게용

## JSX의 정의 : JSXElement, JSXAttributes, JSXChildren, JSXStrings

### 1. JSXElement

JSX를 구성하는 가장 기본 요소로, HTML의 요소(element)와 비슷한 역할을 한다. \*일반 HTML 태그명과 구분하기 위해 사용자 정의 컴포넌트는 대문자로 시작해야 한다.

### 2. JSXAttributes

JSXElement에 부여할 수 있는 속성

### 3. JSXChildren

JSXElement의 자식 값을 나타낸다. JSX는 "**트리 구조**"를 나타내기 위해 만들어졌기에 JSX로 부모 자식 관계를 나타낼 수 있다.

### 4. JSXStrings

HTML에서 사용 가능 -> JSX에서도 사용 가능 : 큰따옴표, 작은따옴표, ..

> HTML과 달리 이스케이프 문자 \를 사용하지 않는다는 중요한 차이점.

# 2.2 가상 DOM과 리액트 파이버

## DOM과 브라우저 렌더링 과정

### 원래 브라우저가 웹페이지를 렌더링하는 과정 (브라우저 DOM 생성)

1. HTML 파일 다운로드
2. HTML을 parsing해서 DOM 노드로 구성된 트리(DOM)을 만든다.
3. (필요시 CSS도 같은 과정을 거친다)
4. 사용자 눈에 보이는 DOM 노드를 순회하며 CSS 스타일 정보도 적용시켜 렌더링한다.

## 가상 DOM의 탄생 배경

어떤 하나의 요소가 변경되면 그 요소의 자식 요소도 전부 변경되어야 해서 비용이 매우 크다.
-> 해결 : 리액트가 관리하는 가상 DOM
방법: 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영

## 가상 DOM을 위한 아키텍처, 리액트 파이버

복잡한 리액트 파이버 설명은 생략하고, 최대한 간단하게 설명하고 넘어갈게요!
![](https://velog.velcdn.com/images/ymj7250/post/56970a0a-fc48-46b0-b886-0b93f6d1a270/image.png)
요소가 추가/수정되면 그때그때마다 DOM을 업데이트하지 않고 가상의 DOM에 업데이트를 시켜본 다음 한번에 업데이트 시킬 수 있는 부분을 모아 한번에 Real DOM에 업데이트시키는(랜더링함) 방식으로 과다 연산을 피할 수 있다.

# 2.3 클래스 컴포넌트와 함수 컴포넌트

## 컴포넌트

**React는 컴포넌트 기반의 UI 라이브러리**로, 단순히 HTML만 가지고 웹페이지를 만드는 것보다 중복 코드를 훨씬 줄여 간결한 코드를 작성할 수 있게 해준다. 컴포넌트는 "재사용되어야 하는 요소"를 말한다.

## 클래스 컴포넌트

클래스 컴포넌트에는 생명주기 메서드가 존재한다. 각 컴포넌트의 특정 시점에서 특정 이벤트들이 발생하게 된다.

> 생명주기 메서드가 실행되는 3가지 시점

1. 마운트 : 컴포넌트가 마운팅(생성)되는 시점
2. 업데이트 : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
3. 언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점

![](https://velog.velcdn.com/images/ymj7250/post/aed81f6d-399d-4d25-b7ab-3f08f0e49b79/image.png)

#### 1. render()

유일한 필수값으로, 컴포넌트가 UI를 렌더링하기 위해 사용된다. 부수 효과 (외부 요소에의 영향) 은 없어야 한다.

#### 2. componentDidMount()

클래스 컴포넌트가 마운트되고 호출되며, 한번 더 렌더링이 시도된다.

#### 3. componentDidUpdate()

컴포넌트 업데이트 이후에 state나 props의 변화에 따라 DOM을 업데이트하는 데에 사용된다.

#### 4. componentWillUnMount()

컴포넌트가 더이상 사용되지 않기 "직전"에 호출된다. 메모리 누수나 불필요한 작동을 위한 함수를 호출하기 위한 최적의 위치이다.

### 클래스 컴포넌트의 한계

1. 여러 시점에서 state가 변할 수 있어 데이터의 흐름을 추적하기 어려움
2. 재사용 컴포넌트를 효율적으로 사용할 수 없음
3. 함수형 컴포넌트보다 사용하기 어려움

## 함수 컴포넌트 vs 클래스 컴포넌트

### 1. 생명주기 메서드의 부재

함수 컴포넌트는 `useEffect` Hook을 사용하여 생명 주기 메서드와 비슷한 효과를 낼 수 있다.

> Hook
> 클래스형 컴포넌트에서만 사용할 수 있는 기능을 "낚아채서" 함수형 컴포넌트에서 사용하는 것.
> 함수형 컴포넌트에서는 Hook이라는 하나의 도구를 사용하여 state와 Lifecycle API의 사용이 가능하다.
> ex) useState, useEffect, useRef..

### 2. 함수 컴포넌트와 랜더링된 값

함수 컴포넌트는 렌더링된 값을 고정한다.
클래스 컴포넌트는 렌더링된 값을 고정할 수 없다.
