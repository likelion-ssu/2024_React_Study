# 7장 크롬 개발자 도구를 활용한 애플리케이션 분석

## 7.1 크롬 개발자 도구란?

**웹페이지에서 일어나는 거의 모든 일을 확인할 수 있는 강력한 개발 도구**

- 개발자 도구를 시작하기 전에..

웹사이트를 제대로 디버깅하고 싶다면 시크릿 모드 또는 프라이빗 모드라 불리는 개인정보 보호 모드에서 페이지와 개발자 도구를 여는 것을 권장

→ Why? 브라우저의 확장 프로그램이 실행을 위해 전역 변수와 HTML 요소에 실제 웹 어플리케이션이 제공하지 않는 다른 정보를 추가


## 7.2 요소 탭

현재 웹페이지를 구성하고 있는 HTML, CSS 등의 정보를 확인할 수 있다.


![Untitled](https://github.com/user-attachments/assets/e7f75944-2f10-4334-9078-e2654722ecc7)


- 요소 탭의 기능
  - 요소 화면에서는 단순히 HTML을 보는 것뿐만 아니라 직접 코드를 수정하여 웹페이지에서 어떻게 변하는지 빠르게 확인할 수 있다.
          
      → 수정하고 싶은 요소를 더블클릭해 태그명이나 클래스 등 요소와 관련된 정보를 수정하거나, 오른쪽 화면에서 스타일을 수정할 수 있다. 
          
      → 이렇게 DOM을 직접적으로 수정하면 개발된 페이지에서 수정된 내용이 어떻게 보이는지 미리 확인할 수 있어 용이하고, 개발 모드에서 리액트 코드를 수정해 핫 리로딩을 거치지 않아도 된다. 
          
      **핫 리로딩**: (애플리케이션 개발 시 코드의 수정사항을 새로고침없이 반영 시켜주는 기능, 'create-react-app'으로 생성된 프로젝트는 기본적으로 핫 리로딩 지원)

  - 요소 화면에서는 코드에 의해 클래스나 속성값이 동적으로 제어되는 DOM이 있다면 요소의 중간점을 사용해 디버깅할 수 있다.


- 요소 탭이 담고 있는 정보

   |이름|기능|
   |---------------|-----------------------------------------------------------------------------------------------------|
   |styles         |어떤 클래스, 태그명, 아이디로 매핑되었는지 확인할 수 있고 수정해 페이지에 어떻게 반영되는지도 확인 가능|
   |computed       |padding, border, margin 등 각종 스타일의 결과값을 알려줌|
   |layout         |css grid나 flexbox와 관련된 정보 제공|
   |Event Listeners|현재 요소에 부착된 각종 이벤트 리스너를 확인 가능|
   |DOM Breakpoints|앞서 말한 중단점이 있는지 알려줌|
   |Properties     |해당 요소가 가지고 있는 모든 속성값을 나타낸다.|
   |Accessibility  |웹 이용에 어려움을 겪는 장애인, 노약자를 위한 스크린 리더기 등이 활용하는 값을 담고 있다.|


## 7.3 소스 탭

- 웹 애플리케이션을 불러오기 위해 실행하거나 참조된 모든 파일을 확인할 수 있는 탭이다.
- 소스 탭의 또 다른 장점
    
     소스 중단점을 생성해 자바스크립트 실행을 중단시키고 디버깅을 수행 할 수 있다.
    
    (소스코드를 오염시키지 않고 디버깅할 수 있어 유용)


## 7.4 네트워크 탭


- HTTP 요청부터 웹 소켓에 이르기까지, 웹페이지가 외부 데이터와 통신하는 정보를 확인핳 때 사용
- 네트워크 탭을 통해 집중적으로 확인해야 하는 점
    - 불필요한 요청 또는 중복되는 요청이 없는지
    
    - 웹페이지 구성에 필요한 리소스 크기가 너무 크지 않은지
        - 리소스 크기가 너무 크다면 gzip, brotli 등을 이용해 리소스를 압축하거나 이미지 최적화
        
    - 리소스를 불러오는 속도는 적절한지 또는 너무 오래 걸리는 리소스는 없는지
    
    - 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지
    
     ex) 노출되는 영역이 큰 중요한 콘텐츠가 우선적으로 다운로드되고, 배경 이미지처럼 우선순위가 비교적 낮은 경우 나중에 다운로드 돼야 함(with 스크린숏 캡처 기능)

    ![Untitled (2)](https://github.com/user-attachments/assets/2f8af5dd-c071-477b-8178-7828ba158bd8)

    **스크린샷 캡처 기능**: 페이지가 마운트될 때의 과정을 특정 간격으로 쪼개 어떤 콘텐츠가 우선적으로 로딩되는지 보여준다 


## 7.5 메모리 탭


![Untitled (3)](https://github.com/user-attachments/assets/f96bcf32-dc20-4ef7-885f-22fc2f51bfaa)


- 메모리 탭에서는 현재 웹페이지가 차지하고 있는 메모리 관련 정보를 확인 가능
  
- 가장 난도 높은 도구
  
- 메모리 누수, 속도 저하, 웹페이지 프리징 현상(화면이 잠깐 멈추거나 스크롤할 때 버벅거림이 발생하는 현상)을 확인할 수 있는 도구

- 메모리 탭은 그 자체만으로는 아무것도 할 수 없으며 프로파일링(분석) 작업을 거쳐야한다.

### 프로파일링 유형

|유형|설명|
|---------------------|--------------------------------------------------------------------------------------|
|힙 스냅샷               |현재 메모리 상황을 사진 찍듯이 촬영 가능, 현재 시점의 메모리 상황을 알고 싶을 때 활용|
|타임라인의 할당 계측    |시간의 흐름에 따른 메모리 변화를 살펴보고 싶을 때 사용, 주로 로딩이 되는 과정의 메모리 변화 또는 페이지에서 어떠한 상호작용을 했을 때 메모리의 변화 과정을 알고 싶을 때 사용|
|할당 샘플링             |메모리 공간을 차지하고 있는 자바스크립트 함수 볼 수 있음                            |

- 7.5.1 자바스크립트 인스턴스 VM 선택
   - 본격적인 프로파일링 전 개발자가 디버깅하고 싶은 자바스크립트 VM 환경을 선택
   - 환경별 힙 크기를 볼 수 있고 이를 통해 해당 페이지가 자바스크립트 힙을 얼마나 점유하는지 확인 가능 힙 크기가 증가하면 브라우저에 부담을 주기 때문에 늘어나지 않는지 주의해야 함.
 

- 7.5.2 힙 스냅샷
   - 과정
        1. 페이지에 진입하고, 페이지 로딩이 완료되면 힙 스냅샷 촬영을 한 번 수행
        2. Bug버튼(왼쪽 상단에 동그란 버튼)을 누르면 한 번 더 스냅샷을 촬영
        3. 메모리 크기 차이의 원인을 알기 위해 모든 객체 메뉴에서 스냅샷 1과 스냅샷 2 사이에 할당된 객체를 클릭해 얕은 크기 항목을 기준으로 내림차순으로 정렬
    
           → 두 스냅샷 간의 비교와 정렬 덕분에 어떤 변수가 메모리를 크게 잡아 먹고 있는지 확인 가능 & 어떤 유저 인터랙션(ex. onClick)으로 메모리 누수가 발생하는지 확인 가능


     ![Untitled](https://github.com/user-attachments/assets/8051b2ce-2e45-48bc-af6b-9e6ae445a396)

  - 얕은 크기와 유지된 크기

      얕은 크기: 객체 자체가 보유한 메모리 바이트의 크기

      유지된 크기: 해당 객체뿐만 아니라다른 부모가 없는 모든 자식 객체들의 크기까지 더한 값

      메모리 누수를 찾을 때는 얕은 크기는 작으나 유지된 크기가 큰 객체를 찾아야 한다. 

      Why? 차이가 큰 객체는 다수의 다른 객체를 참조하고 있다는 뜻 

        → 해당 객체가 복잡한 참조 관계를 지니고 있다.

    EX)

    ```jsx
    var counter = 0
    var instances = []

    function Y() {
      this.j = 5
    }

    function X() {
      this.i = counter++
      this.y = new Y()
    }

    export default function App() {
      function handleClick() {
        instances.push(new X())
      }

      return <button onClick={handleClick}>+</button>
    }
    ```

    이 코드는 버튼을 클릭하면 X라는 이름의 새로운 객체를 생성하는데, 이 생성자 내부에서는 Y라는 새로운 생성자를 생성해 할당한다.

    만약 X에게 할당된 메모리 크기가 52이고 Y에게 할당된 메모리 크기가 48이라면, X의 얕은 크기는 52, 유지된 크기는 100(X의 얕은 크기 + 자식 객체인 Y의 얕은 크기)이 된다. 


 - 7.5.3 타임라인 할당 계측

    - 시간의 흐름에 따라 메모리의 변화를 확인 → 상대적으로 많은 부담
    - 시간에 따른 메모리 점유율을 확인할 때 사용
      
 - 7.5.4 할당 샘플링

    - 시간의 흐름에 따라 발생하는 메모리 점유를 확인한다 → 할당 계측과 동일
    - 자바스크립트 실행 스택별로 분석 가능 & 함수 단위의 분석
    - 타임라인 할당 계측보다 부담을 브라우저에 덜 주는 방식
    - 정확히 어디서 누수가 발생했는지 모를 때 & 장기간 프로파일링을 수행할 때 사용
