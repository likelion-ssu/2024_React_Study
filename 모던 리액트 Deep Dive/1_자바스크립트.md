# 0. 들어가며

## 왜 리액트를 사용할까?

### 1. 단방향 바인딩만을 지원

데이터의 흐름은 오직 한쪽으로만 흐른다. 이런 단방향 데이터 흐름은 어떤 상태의 변화가 일어났을 때 어디서 발생했는지 쉽게 알 수 있게 해주고, 개발자에게 편리함과 유연함을 제공한다.

### 2. JSX(Javascript XML)의 사용

JSX: HTML + 자바스크립트 문법
따로 전용 문법을 익힐 필요가 없다

### 3,4. 비교적 배우기 쉽고 간결/ 강력한 커뮤니티

# 1.1 자바스크립트의 동등 비교

### 자바 스크립트의 데이터 타입

#### 원시타입

: <u>boolean, null, undefined, number, string, symbol, bigint</u>

- **undefined**: 변수 선언 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값
- **null**: 아직 값이 없거나 비어 있는 값을 표현할 때 사용

* null 사용시 주의점: null의 type을 확인하면 'object'로 표시됨.

> undefined와 null의 차이점?
> undefined는 '선언됐지만 할당되지 않은 값', null은 '명시적으로 비어 있음을 나타내기 위해 사용하는 값'으로 사용

#### 객체타입 (reference type)

: object (종류: 배열, 함수, 정규식, 클래스)

- 주의할 점: 객체 타입은 "참조"를 전달한다. 내용이 같아 보여도 참조가 다르면 동등 비교시 false가 반환된다.

### 값을 저장하는 방식의 차이

#### 불변 vs 가변

원시 타입은 **불변 형태**의 값으로 값이 저장되며, 객체타입은 **가변 형태**로 저장된다.

#### 객체타입의 중요한 특징

객체는 "참조"를 저장하기 때문에 같은 속성을 같더라도 서로 다른 객체를 비교하면 반환값으로 false가 전달된다. 참조가 서로 다르기 때문이다.

### 자바스크립트의 또 다른 비교 방식, Object.is

**Object.is**: 자바스크립트에서 제공하는 비교를 위한 방법 중 한 가지. (리액트에서는 이 방식으로 동등 비교를 함.)

1. ==와의 차이
   ==는 비교 전 type casting(강제 형 변환) 후 비교. Object.is는 이 작업을 하지 않음

2. ===와의 차이
   ===가 만족하지 못하는 몇가지 특이 케이스를 추가하기 위해, 나름의 알고리즘으로 작동함. 하지만 객체 비교 원리에는 차이가 없음!!

### 리액트에서의 동등 비교

> 위에서 살펴본 Object.is로 먼저 비교를 수행한 후 Object.is에서 수행하지 못하는 비교, 즉 <u>객체 간 얕은 비교</u>를 한번 더 수행함.

#### 객체 간 얕은 비교

: 객체의 첫번째 깊이에 존재하는 값만 비교한다.

> 그렇다면 왜 첫번째 깊이에 존재하는 값까지만 비교할까?
> 기본적으로 리액트는 객체인 props에서 꺼내온 값을 기준으로 렌더링하기 때문임. props 안에 또다른 객체가 존재하게 되면 (깊이가 2 이상이 되면) 제대로 비교되지 못한다.
> 최적의 성능을 위해 props 안에 또다른 객체가 있는 상황은 고려하지 않는 것.

# 1.2 함수

### 함수란 무엇인가?

함수: 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸 실행 단위로 만들어 놓은 것

### 함수를 정의하는 4가지 방법

#### 1. 함수 선언문 : "일반 문(statement)"

```
function add(a,b){
	return a+b
}
```

#### 2. 함수 표현식

```
const sum = function sum(a,b){
	return a+b
}
```

: sum이라는 변수에 함수 sum을 할당하는, 표현식과 같은 작동

- 일반적으로는 함수 이름을 생략한다. 함수 외부에서 sum을 호출하면 제대로 동작하지 않기에 혼란을 주지 않기 위해서이다.

_짚고 넘어가기
<span style="color:red">_ 호이스팅(hoisting)</span>
**호이스팅**이란, 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징 (메모리에 미리 함수를 올려둔다.)

```
# 함수 선언문
hello() // result: hello

function hello() {
	console.log('hello')
}

# 함수 표현식
hello() // result: TypeError- hello is not a function

var hello = function () {
	console.log('hello')
}
```

코드를 살펴보면, 함수 선언문에 대해서는 호이스팅이 작동하지만, 함수 표현식에 대해서는 호이스팅이 작동하지 않는다.

사실상 hello는 변수이기 때문에 런타임 이전에는 undefined로 초기화되고, 함수 할당문이 실행되는 시점에 실제로 function이 할당되어 작동되기 때문이다.

> 각자 장단점이 있기 때문에 상황에 맞게 선택하여 사용하면 된다.

#### 3. Function 생성자

```
const add = new Function('a', 'b', 'return a + b')

add(10, 24) //34
```

일반적으로는 사용하지 않는다.

#### 4. 화살표 함수

```
const add = (a, b) => {
	return a + b
}

const add = (a, b) => a + b
```

> 화살표 함수는 다른 함수 정의 방식과 차이점이 존재한다.

1. constructor 사용 불가
2. arguments 존재하지 않음
3. this 바인딩 방식의 차이

- 함수 자체의 바인딩을 갖지 않아 화살표 함수 내부에서 this 참조시 상위 스코프의 this를 그대로 따르게 된다.

### 다양한 함수 살펴보기

#### 1. 즉시 실행 함수

함수의 선언과 실행은 그 자리에서 끝남. 재사용되지 않는 일회성 함수에서 사용!

```
(function (a,b){
	return a+b
})(10,24);
```

#### 2. 고차 함수

함수를 인수로 받거나 결과로 새로운 함수를 반환하는 경우

```
// 대표적으로 함수를 인수로 받는 경우: map 함수
const doubledArray = [1,2,3].map((item) => item * 2)

// 대표적으로 함수를 반환하는 경우
const add = function (a) {
	return function (b) {
    	return a + b
    }
}

add(1)(3)
```

> 클로저 이해
> ![](https://velog.velcdn.com/images/ymj7250/post/c3ee7964-0df3-4cc0-9807-c0aa47b25613/image.png)

### 함수를 만들 때 주의해야 할 사항

1. 최대한 "순수 함수"로 만들기
   함수 외부에 영향을 미치는 것을 "함수의 부수 효과"라고 한다. 이 함수의 부수 효과를 최대한 억제해야 개발하기 더 좋다.
2. 가능한 한 함수를 작게 만들기
   하나의 함수에서 너무 많은 일을 하게 하지 말고, 최대한 나눠라.
3. 누구나 이해할 수 있는 이름을 붙여라

# 1.3 클래스

현재 우리는 대부분 함수형 컴포넌트로 개발을 진행하지만, 클래스형 컴포넌트도 이해해보면 전체적인 개념을 잡는 데에 도움을 줄 것이다.

### 클래스란 무엇인가

특정한 객체를 만들기 위한 일종의 템플릿, 하나의 "틀"
![](https://velog.velcdn.com/images/ymj7250/post/d7ab6916-c8a6-4b9a-8073-9fb53810eeb5/image.png)

### 클래스와 함수의 관계

바벨로 변환: 자바스크립트 코드를 구버전으로 변환 (생략)

# 1.4 클로저

### 클로저의 정의

클로저: 함수와 함수가 선언된 어휘적 환경의 조합 \*어휘적 환경: 변수가 코드 내부에서 어디서 선언됐는가?

### 변수의 유효 범위, 스코프

#### (1) 전역 스코프

```
var global = 'global scope'
```

브라우저 환경에서 전역 객체는 window에 바인딩되어 `window.global`로 접근 가능

#### (2) 함수 스코프

다른 언어와는 달리 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. _즉, {} 블록이 스코프 범위를 결정하지 않는다._

```
// 함수 레벨 스코프를 따르는 경우
if (true) {
	var global = 'global scope'
}

console.log(global) // result: global

// { } 블록이 스코프 범위를 결정하는 경우 (블록 레벨 스코프)
function hello(){
	var local = 'local variable'
}

console.log(local) // result: local is not defined error
```

### 클로저의 활용

![](https://velog.velcdn.com/images/ymj7250/post/bb1f8832-c548-460c-8aff-d9fa7d313938/image.png)

<hr>

변수가 전역으로 선언되어있다면 누구나 `window.{global 변수 이름}`을 통해 접근 및 수정을 통해 리액트 어플리케이션을 망가뜨릴 수 있다.

따라서 리액트에서는 클로저를 활용하여 위의 상황이 발생하는 것을 막는다.

#### 대표적인 클로저의 활용: useState

![](https://velog.velcdn.com/images/ymj7250/post/75016e4b-1c20-421c-87b0-a2129c124ea6/image.png)
useState는 오직 1번만 호출되나, useState가 반환하는 내부함수 setState는 "환경"을 기억하기 때문에 계속해서 state값을 사용할 수 있다.

### 주의할 점

![](https://velog.velcdn.com/images/ymj7250/post/f136eaad-bcd0-4237-b3b4-fac009e2dc2c/image.png)

+) 클로저 사용시 성능이 저하될 가능성이 있음. 따라서 꼭 필요한 작업만 클로저에 남겨둬야 한다.

# 1.5 이벤트 루프와 비동기 통신의 이해

기본적으로 자바스크립트는 싱글 스레드에서 작동하며, 오직 한 번에 하나의 작업만 동기 방식으로 처리할 수 있다.
하지만 자바스크립트는 분명히 많은 것들을 비동기로 작동시키고 있다. 이것이 어떻게 가능할지 알아본다.

### 싱글 스레드 자바스크립트

프로세스: 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위
스레드: 하나의 프로세스에서의 각 작업을 일컫는 단위

멀티스레드의 문제점: 여러 개의 작업이 하나의 메모리를 공유하게 되기 때문에 "동시성 문제"가 발생할 수 있음
싱글스레드의 문제점: 하나의 작업이 끝나기 전까지 다른 작업이 실행되지 않아 매우 비효율적

### 이벤트 루프란?

이벤트 루프: 자바 스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치

#### 호출 스택과 태스크 큐

**태스크 큐**: 실행해야 할 태스크의 집합
ex) 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미
이벤트 루프의 역할: 호출 스택에 실행 중인 코드가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다. 호출 스택이 비었다면 태스크 큐에 대기 중인 작업이 있는지 확인하고 이 작업을 실행 가능한 오래된 것부터 순차적으로 꺼내와 실행한다.
![](https://velog.velcdn.com/images/ymj7250/post/4c633e1c-4530-4edf-8bce-51e7e02b3f1d/image.png)
![](https://velog.velcdn.com/images/ymj7250/post/b6675c9a-0463-4254-8383-f03308e33511/image.png)

setTimeout함수에 대해 n초가 지났어요~ 이제 함수를 실행해주세요를 요청하는 것은 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드이다. ex) 브라우저, Node.js..
-> 자바스크립트 코드는 메인(싱글) 스레드에서 실행, 외부 API 등은 모두 자바스크립트 코드 외부에서 실행되고 그 콜백이 태스크 큐에 들어가는 것. 이런 식으로 자바스크립트는 작동하기에 비동기 작업을 수행할 수 있는 것임.

### 태스크 큐와 마이크로 태스크 큐

마이크로 태스크 큐는 태스크 큐보다 높은 우선순위를 가짐. 마이크로 태스크 큐에 들어가는 대표적인 작업은 `Promise`임.
랜더링 기준 : 마이크로 태스크 큐를 실행한 후. (각 마이크로 태스크 큐 작업이 끝날 때마다 랜더링 기회를 얻게 됨)

# 1.6 리액트에서 자주 사용하는 자바스크립트 문법

### 구조분해 할당

#### 배열 구조분해 할당

: **, 의 위치**에 따라 값이 결정된다.

```
const array= [1,2,3,4,5]
const [first, , , , fifth] = array

first //1
fifth //5
```

#### 객체 구조분해 할당

: 객체 내부 이름으로 꺼내온다.
![](https://velog.velcdn.com/images/ymj7250/post/e1515d4f-ac20-4cf0-94b7-1592abbfd21a/image.png)
\*spread 연산자를 사용한 rest element는 맨 마지막 원소가 되어야 한다.

### 전개 구문 (spread 연산자)

합성이 매우 쉬워진다.
![](https://velog.velcdn.com/images/ymj7250/post/2ad27d63-10f9-4812-8c0f-4e364d05bcae/image.png)
\*spread 연산자의 위치에 따라 값이 아예 달라지기에 유의해야 한다.

### 객체 초기자

객체 선언 시 객체에 넣고자 하는 키:값을 가지고 있는 변수가 이미 존재하면 해당 값을 간결하게 넣어줌
![](https://velog.velcdn.com/images/ymj7250/post/c11b582a-3c70-4121-8ff7-bfba942486d3/image.png)

### Array 프로토타입의 메서드: map, filter, reduce, forEach

#### 1. map

```
const arr= [1,2,3,4,5]
const doubledArr = arr.map((item) => item * 2 )
```

배열을 인수로 받고, 인수로 받은 배열의 각 item에 대해 콜백함수를 실행하여 기존 배열과 같은 size의 새로운 배열을 반환해준다.

\*이렇게 사용하면 반복되는 코드를 줄일 수 있어용 : 특정 배열을 기반으로 리액트 요소를 반환

```
const arr [ 1,2,3,4,5]
const Elements = arr.map((item)=>{
	return <Fragment key={item}>{item}</Fragment>
}
```

#### 2. filter

인수로 받은 콜백함수에 대해 truthy 조건을 만족하는 경우에만 해당 원소를 반환하여 원본 배열 길이 이하의 새로운 배열이 반환된다.

```
const arr= [1,2,3,4,5]
const evenArr = arr.filter((item)=> item % 2 === 0 )
// 결과: [2,4]
```

#### 3. reduce

콜백 함수를 실행하고, 이를 초깃값에 누적해 결과를 반환

```
const arr = [1,2,3,4,5]
const sum = arr.reduce((result, item) => {
	return result + item
}, 0)
```

0은 result의 초깃값, arr의 원소들이 result에 누적되어 더해진다.

#### 4. forEach

콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백함수를 실행하기만 하는 메서드

```
const arr = [1,2,3]
arr.forEach((item)=> console.log(item))
```

forEach의 주의점)

1. 반환값이 없음
2. forEach는 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 멈출 수 없음. <span style="color:red">break, return 등등도 안 먹힘!!</span>

### 삼항 조건 연산자

```
function Component( { condition } ) {
	return <>{condition ? "참" : "거짓" } </>
}
```

JSX 내부에서 조건부로 렌더링하기 위해 가장 널리 쓰이는 방법

# 1.7 타입스크립트

생략하였습니다.
